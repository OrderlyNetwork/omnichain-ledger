{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { MessagingReceipt, MessagingFee } from \"../../oapp/OAppSender.sol\";\n\n/**\n * @dev Struct representing token parameters for the OFT send() operation.\n */\nstruct SendParam {\n    uint32 dstEid; // Destination endpoint ID.\n    bytes32 to; // Recipient address.\n    uint256 amountLD; // Amount to send in local decimals.\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n    bytes composeMsg; // The composed message for the send() operation.\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n}\n\n/**\n * @dev Struct representing OFT limit information.\n * @dev These amounts can change dynamically and are up the the specific oft implementation.\n */\nstruct OFTLimit {\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\n}\n\n/**\n * @dev Struct representing OFT receipt information.\n */\nstruct OFTReceipt {\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\n}\n\n/**\n * @dev Struct representing OFT fee details.\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\n */\nstruct OFTFeeDetail {\n    int256 feeAmountLD; // Amount of the fee in local decimals.\n    string description; // Description of the fee.\n}\n\n/**\n * @title IOFT\n * @dev Interface for the OftChain (OFT) token.\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\n * @dev This specific interface ID is '0x02e49c2c'.\n */\ninterface IOFT {\n    // Custom error messages\n    error InvalidLocalDecimals();\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\n\n    // Events\n    event OFTSent(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 dstEid, // Destination Endpoint ID.\n        address indexed fromAddress, // Address of the sender on the src chain.\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n    event OFTReceived(\n        bytes32 indexed guid, // GUID of the OFT message.\n        uint32 srcEid, // Source Endpoint ID.\n        address indexed toAddress, // Address of the recipient on the dst chain.\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\n    );\n\n    /**\n     * @notice Retrieves interfaceID and the version of the OFT.\n     * @return interfaceId The interface ID.\n     * @return version The version.\n     *\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\n     */\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\n\n    /**\n     * @notice Retrieves the address of the token associated with the OFT.\n     * @return token The address of the ERC20 token implementation.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\n     * @return requiresApproval Needs approval of the underlying token implementation.\n     *\n     * @dev Allows things like wallet implementers to determine integration requirements,\n     * without understanding the underlying token implementation.\n     */\n    function approvalRequired() external view returns (bool);\n\n    /**\n     * @notice Retrieves the shared decimals of the OFT.\n     * @return sharedDecimals The shared decimals of the OFT.\n     */\n    function sharedDecimals() external view returns (uint8);\n\n    /**\n     * @notice Provides a quote for OFT-related operations.\n     * @param _sendParam The parameters for the send operation.\n     * @return limit The OFT limit information.\n     * @return oftFeeDetails The details of OFT fees.\n     * @return receipt The OFT receipt information.\n     */\n    function quoteOFT(\n        SendParam calldata _sendParam\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\n\n    /**\n     * @notice Provides a quote for the send() operation.\n     * @param _sendParam The parameters for the send() operation.\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\n     *\n     * @dev MessagingFee: LayerZero msg fee\n     *  - nativeFee: The native fee.\n     *  - lzTokenFee: The lzToken fee.\n     */\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\n\n    /**\n     * @notice Executes the send() operation.\n     * @param _sendParam The parameters for the send operation.\n     * @param _fee The fee information supplied by the caller.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\n     * @return receipt The LayerZero messaging receipt from the send() operation.\n     * @return oftReceipt The OFT receipt information.\n     *\n     * @dev MessagingReceipt: LayerZero msg receipt\n     *  - guid: The unique identifier for the sent message.\n     *  - nonce: The nonce of the sent message.\n     *  - fee: The LayerZero fee incurred for the message.\n     */\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nlibrary OFTComposeMsgCodec {\n    // Offset constants for decoding composed messages\n    uint8 private constant NONCE_OFFSET = 8;\n    uint8 private constant SRC_EID_OFFSET = 12;\n    uint8 private constant AMOUNT_LD_OFFSET = 44;\n    uint8 private constant COMPOSE_FROM_OFFSET = 76;\n\n    /**\n     * @dev Encodes a OFT composed message.\n     * @param _nonce The nonce value.\n     * @param _srcEid The source endpoint ID.\n     * @param _amountLD The amount in local decimals.\n     * @param _composeMsg The composed message.\n     * @return _msg The encoded Composed message.\n     */\n    function encode(\n        uint64 _nonce,\n        uint32 _srcEid,\n        uint256 _amountLD,\n        bytes memory _composeMsg // 0x[composeFrom][composeMsg]\n    ) internal pure returns (bytes memory _msg) {\n        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);\n    }\n\n    /**\n     * @dev Retrieves the nonce from the composed message.\n     * @param _msg The message.\n     * @return The nonce value.\n     */\n    function nonce(bytes calldata _msg) internal pure returns (uint64) {\n        return uint64(bytes8(_msg[:NONCE_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the source endpoint ID from the composed message.\n     * @param _msg The message.\n     * @return The source endpoint ID.\n     */\n    function srcEid(bytes calldata _msg) internal pure returns (uint32) {\n        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the amount in local decimals from the composed message.\n     * @param _msg The message.\n     * @return The amount in local decimals.\n     */\n    function amountLD(bytes calldata _msg) internal pure returns (uint256) {\n        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));\n    }\n\n    /**\n     * @dev Retrieves the composeFrom value from the composed message.\n     * @param _msg The message.\n     * @return The composeFrom value.\n     */\n    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {\n        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);\n    }\n\n    /**\n     * @dev Retrieves the composed message.\n     * @param _msg The message.\n     * @return The composed message.\n     */\n    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {\n        return _msg[COMPOSE_FROM_OFFSET:];\n    }\n\n    /**\n     * @dev Converts an address to bytes32.\n     * @param _addr The address to convert.\n     * @return The bytes32 representation of the address.\n     */\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    /**\n     * @dev Converts bytes32 to an address.\n     * @param _b The bytes32 value to convert.\n     * @return The address representation of bytes32.\n     */\n    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {\n        return address(uint160(uint256(_b)));\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/lib/ChainedEventIdCounter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nabstract contract ChainedEventIdCounter {\n    /// @notice Mapping of srcChainId => event id\n    mapping(uint256 => uint256) public srcChainIdToEventId;\n\n    /// @notice Increment event id for source chain and return it\n    function _getNextChainedEventId(uint256 srcChainId) internal returns (uint256) {\n        srcChainIdToEventId[srcChainId]++;\n        return srcChainIdToEventId[srcChainId];\n    }\n\n    // gap for upgradeable\n    uint256[5] private __gap;\n}\n"
    },
    "contracts/lib/ILedgerOCCManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {OCCLedgerMessage} from \"./OCCTypes.sol\";\n\ninterface ILedgerOCCManager {\n    function ledgerSendToVault(OCCLedgerMessage memory message) external payable;\n\n    function collectUnvestedOrders(uint256 amount) external;\n}\n"
    },
    "contracts/lib/LedgerAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nabstract contract LedgerAccessControl is Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\n    function ledgerAccessControlInit(address owner) internal onlyInitializing {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n    }\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    /// @notice Pause external functionality\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpause external functionality\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // gap for upgradeable\n    uint256[5] private __gap;\n}\n"
    },
    "contracts/lib/LedgerTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerToken} from \"./OCCTypes.sol\";\n\nenum PayloadDataType {\n    /* ====== Payloads From vault side ====== */\n    ClaimReward,\n    Stake,\n    CreateOrderUnstakeRequest,\n    CancelOrderUnstakeRequest,\n    WithdrawOrder,\n    EsOrderUnstakeAndVest,\n    CancelVestingRequest,\n    CancelAllVestingRequests,\n    ClaimVestingRequest,\n    RedeemValor,\n    ClaimUsdcRevenue,\n    /* ====== Backward Payloads from ledger side ====== */\n    ClaimRewardBackward,\n    WithdrawOrderBackward,\n    ClaimVestingRequestBackward,\n    ClaimUsdcRevenueBackward\n}\n\n// Suppose that in the OCCVaultMessage, the sender and chainId can be used to get the chainId and user address for all the calls\n// For deposited calls like Stake, LedgerToken and amount should be filled in the OCCVaultMessage\n// For calls where only the user address and chainId are needed no additional structure payload needed.\n// Calls without payload: Stake, WithdrawOrder, ClaimUsdcRevenue\n\nlibrary LedgerPayloadTypes {\n    struct ClaimReward {\n        uint32 distributionId;\n        uint256 cumulativeAmount;\n        bytes32[] merkleProof;\n    }\n\n    struct CreateOrderUnstakeRequest {\n        uint256 amount;\n    }\n\n    struct EsOrderUnstakeAndVest {\n        uint256 amount;\n    }\n\n    struct CancelVestingRequest {\n        uint256 requestId;\n    }\n\n    struct ClaimVestingRequest {\n        uint256 requestId;\n    }\n\n    struct RedeemValor {\n        uint256 amount;\n    }\n}\n\nlibrary LedgerSignedTypes {\n    struct UintValueData {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint256 value;\n        uint64 timestamp;\n    }\n}\n"
    },
    "contracts/lib/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerToken} from \"./OCCTypes.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport {LedgerAccessControl} from \"./LedgerAccessControl.sol\";\nimport {ChainedEventIdCounter} from \"./ChainedEventIdCounter.sol\";\n\n/**\n * @title MerkleDistributor\n * @author Orderly Network\n * @notice This contract aimed for the distribution of\n *         - Trading rewards\n *         - Market Maker rewards\n *\n *         Contract allows to create distributions and propose updated Merkle roots for them.\n *         Each distribution has it's own token, that can't be changed after creation.\n *         Several distributions can have the same token.\n *         Distribution supports two types of tokens: $ORDER and es$ORDER (record based).\n *         Contract supports distribution of continuously growing rewards. Wor that purpose, it supports root updates for distributions.\n *         Next root should contain cummulative (not decreasing) amount of rewards for each user from the previous root.\n *         Contract does not transfer tokens to the users, it only returns the type and amount of tokens that user claimed.\n *         Contract supposed to be a part of the Ledger contract.\n *         Parent contract should implement the claimRewards function that will call _claimRewards function from this contract.\n */\n\nabstract contract MerkleDistributor is LedgerAccessControl, ChainedEventIdCounter {\n    /// @dev May create distributions and propose updated Merkle roots for them.\n    bytes32 public constant ROOT_UPDATER_ROLE = keccak256(\"ROOT_UPDATER_ROLE\");\n\n    struct MerkleTree {\n        /// @dev The Merkle root.\n        bytes32 merkleRoot;\n        /// @dev The timestamp when this Merkle root become active.\n        uint256 startTimestamp;\n        /// @dev An IPFS CID pointing to the Merkle tree data.\n        bytes ipfsCid;\n    }\n\n    struct Distribution {\n        /// @dev Token of the distribution.\n        LedgerToken token;\n        /// @dev The Merkle root and associated parameters.\n        MerkleTree merkleTree;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev Mapping of (distribution id) => (active Distribution).\n    mapping(uint32 => Distribution) internal activeDistributions;\n\n    /// @dev Mapping of (distribution id) => (proposed Merkle root).\n    mapping(uint32 => MerkleTree) internal proposedRoots;\n\n    /// @dev Mapping of (distribution id) => (user address) => (claimed amount).\n    mapping(uint32 => mapping(address => uint256)) internal claimedAmounts;\n\n    /* ========== EVENTS ========== */\n\n    /// @notice Emitted when a new distribution is created by the ROOT_UPDATER_ROLE from Ledger chain.\n    event DistributionCreated(\n        uint256 indexed eventId,\n        uint32 indexed distributionId,\n        LedgerToken token,\n        bytes32 merkleRoot,\n        uint256 startTimestamp,\n        bytes ipfsCid\n    );\n\n    /// @notice Emitted when a new Merkle root is proposed by the ROOT_UPDATER_ROLE from Ledger chain.\n    event RootProposed(uint256 indexed eventId, uint32 indexed distributionId, bytes32 merkleRoot, uint256 startTimestamp, bytes ipfsCid);\n\n    /// @notice Emitted when proposed Merkle root becomes active by the ROOT_UPDATER_ROLE from Ledger chain.\n    event RootUpdated(uint256 indexed eventId, uint32 indexed distributionId, bytes32 merkleRoot, uint256 startTimestamp, bytes ipfsCid);\n\n    /// @notice Emitted when a user claims rewards from Vault chains.\n    event RewardsClaimed(\n        uint256 indexed chainedEventId,\n        uint256 indexed chainId,\n        uint32 indexed distributionId,\n        address account,\n        uint256 amount,\n        LedgerToken token\n    );\n\n    /* ========== ERRORS ========== */\n\n    error DistributionAlreadyExists();\n    error TokenIsNotSupportedForDistribution();\n    error DistributionNotFound();\n    error ProposedMerkleRootIsZero();\n    error StartTimestampIsInThePast();\n    error ThisMerkleRootIsAlreadyProposed();\n    error CannotUpdateRoot();\n    error NoActiveMerkleRoot();\n    error InvalidMerkleProof();\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyUpdater() {\n        _checkRole(ROOT_UPDATER_ROLE);\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function merkleDistributorInit(address owner) internal onlyInitializing {\n        _grantRole(ROOT_UPDATER_ROLE, owner);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice Get the active Merkle root for distribution id and associated parameters.\n     *         If distribution has proposed root and it's start timestamp has passed, proposed root will be returned.\n     *         It allows to reduce probability of collision when user claiming rewards from the old Merkle root.\n     *         Because it will be updated at the beginning of the next claimReward call and become active from that moment.\n     *         So, user will actually obtain the rewards from the proposed root and have to provide amount and proof for it.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     * @return  token          The type of the distributed token. Currently only $ORDER token and es$ORDER (record based) are supported.\n     * @return  merkleRoot     The Merkle root.\n     * @return  startTimestamp Timestamp when this Merkle root become active.\n     * @return  ipfsCid        An IPFS CID pointing to the Merkle tree data (optional, can be 0x0).\n     */\n    function getDistribution(\n        uint32 _distributionId\n    ) external view returns (LedgerToken token, bytes32 merkleRoot, uint256 startTimestamp, bytes memory ipfsCid) {\n        if (canUpdateRoot(_distributionId)) {\n            return (\n                activeDistributions[_distributionId].token,\n                proposedRoots[_distributionId].merkleRoot,\n                proposedRoots[_distributionId].startTimestamp,\n                proposedRoots[_distributionId].ipfsCid\n            );\n        }\n        return (\n            activeDistributions[_distributionId].token,\n            activeDistributions[_distributionId].merkleTree.merkleRoot,\n            activeDistributions[_distributionId].merkleTree.startTimestamp,\n            activeDistributions[_distributionId].merkleTree.ipfsCid\n        );\n    }\n\n    /**\n     * @notice Check if the distribution is record based. Currently only es$ORDER token is record based.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     * @return Boolean `true` if the distribution is record based, else `false`.\n     */\n    function isDistributionRecordBased(uint32 _distributionId) external view returns (bool) {\n        return activeDistributions[_distributionId].token == LedgerToken.ESORDER;\n    }\n\n    /**\n     * @notice Get the proposed Merkle root for token and associated parameters.\n     *         When the proposed root become active, it will be removed from the proposedRoots mapping.\n     *         So, this function will return non-zero values only if the proposed root is pending.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     * @return  merkleRoot     The proposed Merkle root.\n     * @return  startTimestamp Timestamp when this Merkle root become active.\n     * @return  ipfsCid        An IPFS CID pointing to the Merkle tree data (optional, can be 0x0).\n     */\n    function getProposedRoot(uint32 _distributionId) external view returns (bytes32 merkleRoot, uint256 startTimestamp, bytes memory ipfsCid) {\n        return (proposedRoots[_distributionId].merkleRoot, proposedRoots[_distributionId].startTimestamp, proposedRoots[_distributionId].ipfsCid);\n    }\n\n    /**\n     * @notice Get the tokens amount claimed so far for distribution by a given user.\n     *\n     * @param  _distributionId  The distribution id.\n     * @param  _user  The address of the user.\n     *\n     * @return The amount tokens claimed so far by that user.\n     */\n    function getClaimed(uint32 _distributionId, address _user) external view returns (uint256) {\n        return claimedAmounts[_distributionId][_user];\n    }\n\n    /**\n     * @notice Returns true if there is a proposed root for given distribution waiting to become active.\n     *         This is the case if the proposed root for given distribution is not zero.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     * @return Boolean `true` if there is a proposed root for given distribution waiting to become active, else `false`.\n     */\n    function hasPendingRoot(uint32 _distributionId) public view returns (bool) {\n        return proposedRoots[_distributionId].merkleRoot != bytes32(0);\n    }\n\n    /**\n     * @notice Returns true if there is a proposed root for given distribution waiting to become active\n     *         and the start time has passed.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     * @return Boolean `true` if the active root can be updated to the proposed root, else `false`.\n     */\n    function canUpdateRoot(uint32 _distributionId) public view returns (bool) {\n        return hasPendingRoot(_distributionId) && block.timestamp >= proposedRoots[_distributionId].startTimestamp;\n    }\n\n    /* ========== DISTRIBUTION CREATION AND ROOT UPDATES ========== */\n\n    /**\n     * @notice Create a new distribution with the given token and propose Merkle root for it.\n     *         Locked for ROOT_UPDATER_ROLE.\n     *         Once created, distribution token can't be changed.\n     *\n     * @param  _distributionId  The distribution id.\n     * @param  _token           The type of the token. Currently only $ORDER token and es$ORDER (record based) are supported.\n     * @param  _merkleRoot      The Merkle root.\n     * @param  _startTimestamp  The timestamp when this Merkle root become active.\n     * @param  _ipfsCid         An IPFS CID pointing to the Merkle tree data. (optional, can be 0x0)\n     *\n     * Reverts if the distribution with the same id is already exists or Merkle root params are invalid.\n     * Reverts if the token is not supported for distribution. Currently only $ORDER and es$ORDER tokens are supported.\n     */\n    function createDistribution(\n        uint32 _distributionId,\n        LedgerToken _token,\n        bytes32 _merkleRoot,\n        uint256 _startTimestamp,\n        bytes calldata _ipfsCid\n    ) external whenNotPaused nonReentrant onlyUpdater {\n        if (_distributionExists(_distributionId)) revert DistributionAlreadyExists();\n        if (_token != LedgerToken.ORDER && _token != LedgerToken.ESORDER) revert TokenIsNotSupportedForDistribution();\n\n        // Creates distribution with empty merkleTree. Proposed root will be set in the next step.\n        activeDistributions[_distributionId] = Distribution({\n            token: _token,\n            merkleTree: MerkleTree({merkleRoot: \"\", startTimestamp: 1, ipfsCid: \"\"})\n        });\n\n        // Check and propose root for the created distribution. It become active after startTimestamp passed.\n        _proposeRoot(_distributionId, _merkleRoot, _startTimestamp, _ipfsCid);\n\n        emit DistributionCreated(_getNextChainedEventId(0), _distributionId, _token, _merkleRoot, _startTimestamp, _ipfsCid);\n    }\n\n    /**\n     * @notice Set the proposed root parameters.\n     *         Locked for ROOT_UPDATER_ROLE.\n     *         Allows to update proposed root for token before startTimestamp passed.\n     *         If startTimestamp passed, proposed root will be propogated to active root.\n     *\n     * @param  _distributionId  The distribution id.\n     * @param  _merkleRoot     The Merkle root.\n     * @param  _startTimestamp The timestamp when this Merkle root become active\n     * @param  _ipfsCid        An IPFS CID pointing to the Merkle tree data.\n     *\n     *  Reverts if the proposed root is bytes32(0).\n     *  Reverts if the proposed startTimestamp is in the past.\n     *  Reverts if the proposed root is already proposed.\n     */\n    function proposeRoot(\n        uint32 _distributionId,\n        bytes32 _merkleRoot,\n        uint256 _startTimestamp,\n        bytes calldata _ipfsCid\n    ) public whenNotPaused nonReentrant onlyUpdater {\n        _proposeRoot(_distributionId, _merkleRoot, _startTimestamp, _ipfsCid);\n    }\n\n    /**\n     * @notice Propagate proposed root to the distribution if it can be updated.\n     *         Non-reeentrant guard is disabled because this function is called from claimRewards.\n     *\n     * @param  _distributionId  The distribution id.\n     *\n     *  Reverts if root updates are paused.\n     *  Reverts if the proposed root is bytes32(0).\n     *  Reverts if the waiting period for the proposed root has not elapsed.\n     */\n    function updateRoot(uint32 _distributionId) public whenNotPaused {\n        if (!canUpdateRoot(_distributionId)) revert CannotUpdateRoot();\n\n        activeDistributions[_distributionId].merkleTree = proposedRoots[_distributionId];\n        delete proposedRoots[_distributionId];\n\n        emit RootUpdated(\n            _getNextChainedEventId(0),\n            _distributionId,\n            activeDistributions[_distributionId].merkleTree.merkleRoot,\n            activeDistributions[_distributionId].merkleTree.startTimestamp,\n            activeDistributions[_distributionId].merkleTree.ipfsCid\n        );\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /**\n     * @notice Check Merkle proof and claim the remaining unclaimed rewards for a user.\n     *         Will propogate pending Merkle root updates before claiming if startTimestamp for pending root has passed.\n     *         Return the type of token and claimable amount.\n     *         Caller (Ledger contract) should transfer the token to the user or stake if token is record based.\n     *\n     *  Reverts if there is no active distribution for the _distributionId.\n     *  Reverts if no active Merkle root is set for the _distributionId.\n     *  Reverts if the provided Merkle proof is invalid.\n     */\n    function _claimRewards(\n        uint32 _distributionId,\n        address _user,\n        uint256 _srcChainId,\n        uint256 _cumulativeAmount,\n        bytes32[] memory _merkleProof\n    ) internal whenNotPaused nonReentrant returns (LedgerToken token, uint256 claimableAmount) {\n        if (canUpdateRoot(_distributionId)) {\n            updateRoot(_distributionId);\n        }\n\n        // Distribution should be created (has not null token address).\n        if (!_distributionExists(_distributionId)) revert DistributionNotFound();\n\n        // Verify the Merkle proof.\n        {\n            // Get the active Merkle root.\n            MerkleTree storage activeMerkleTree = activeDistributions[_distributionId].merkleTree;\n            if (activeMerkleTree.merkleRoot == bytes32(0)) revert NoActiveMerkleRoot();\n            bytes32 merkleRoot = activeMerkleTree.merkleRoot;\n\n            // Verify the Merkle proof.\n            bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_user, _cumulativeAmount))));\n            if (!MerkleProof.verify(_merkleProof, merkleRoot, leaf)) revert InvalidMerkleProof();\n        }\n\n        // Note: If next operation reverts, then there was an error in the Merkle tree, since the cumulative\n        // amount for a given user should never decrease over time.\n        claimableAmount = _cumulativeAmount - claimedAmounts[_distributionId][_user];\n        token = activeDistributions[_distributionId].token;\n\n        claimedAmounts[_distributionId][_user] = _cumulativeAmount;\n\n        if (claimableAmount > 0) {\n            emit RewardsClaimed(_getNextChainedEventId(_srcChainId), _srcChainId, _distributionId, _user, claimableAmount, token);\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @notice Check params and propose root for the distribution.\n     */\n    function _proposeRoot(uint32 _distributionId, bytes32 _merkleRoot, uint256 _startTimestamp, bytes calldata _ipfsCid) private {\n        if (!_distributionExists(_distributionId)) revert DistributionNotFound();\n\n        if (_merkleRoot == bytes32(0)) revert ProposedMerkleRootIsZero();\n\n        if (_startTimestamp < block.timestamp) revert StartTimestampIsInThePast();\n\n        if (\n            _merkleRoot == proposedRoots[_distributionId].merkleRoot &&\n            _startTimestamp == proposedRoots[_distributionId].startTimestamp &&\n            keccak256(_ipfsCid) == keccak256(proposedRoots[_distributionId].ipfsCid)\n        ) revert ThisMerkleRootIsAlreadyProposed();\n\n        if (canUpdateRoot(_distributionId)) {\n            updateRoot(_distributionId);\n        }\n\n        // Set the proposed root and the start timestamp when proposed root to become active.\n        proposedRoots[_distributionId] = MerkleTree({merkleRoot: _merkleRoot, startTimestamp: _startTimestamp, ipfsCid: _ipfsCid});\n\n        emit RootProposed(_getNextChainedEventId(0), _distributionId, _merkleRoot, _startTimestamp, _ipfsCid);\n    }\n\n    /**\n     * @dev Checks if the distribution exists.\n     * @param _distributionId The distribution id.\n     * @return Boolean `true` if the distribution exists, else `false`.\n     */\n    function _distributionExists(uint32 _distributionId) private view returns (bool) {\n        return activeDistributions[_distributionId].merkleTree.startTimestamp != 0;\n    }\n\n    // gap for upgradeable\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/OCCTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\n/// @dev The token types that can be transferred\nenum LedgerToken {\n    ORDER,\n    ESORDER,\n    USDC,\n    PLACEHOLDER\n}\n\nstruct OCCVaultMessage {\n    /// @dev the source chain id, the sender can omit this field\n    uint256 srcChainId;\n    /// @dev the symbol of the token\n    LedgerToken token;\n    /// @dev the amount of token\n    uint256 tokenAmount;\n    /// @dev the address of the sender\n    address sender;\n    /// @dev payloadType is the type of the payload\n    uint8 payloadType;\n    /// @dev payload is the data to be sent\n    bytes payload;\n}\n\nstruct OCCLedgerMessage {\n    /// @dev the destination chain id\n    uint256 dstChainId;\n    /// @dev the symbol of the token\n    LedgerToken token;\n    /// @dev the amount of token\n    uint256 tokenAmount;\n    /// @dev the address of the receiver\n    address receiver;\n    /// @dev payloadType is the type of the payload\n    uint8 payloadType;\n    /// @dev payload is the data to be sent\n    bytes payload;\n}\n"
    },
    "contracts/lib/Revenue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerAccessControl} from \"./LedgerAccessControl.sol\";\nimport {ChainedEventIdCounter} from \"./ChainedEventIdCounter.sol\";\nimport {Valor} from \"./Valor.sol\";\n\n/**\n * @title Revenue\n * @author Orderly Network\n * @notice Contract that allow users to redeem valor and claim USDC revenue for valor\n *         Revenue is calculated per batch, that is 14 days long; Contract\n *         User can redeem valor only for current batch\n *         User can make several redemption requests for one batch, the amount will be summed\n *         User create redemption request for the chain, that is used in the request\n *         Redemption request can't be cancelled or revoked\n *         CeFi fixes valor to USDC rate for the batch after providing daily USDC net fee amount after batch is finished\n *         Then admin marks batch as claimable when USDC is provided for the batch\n *         User can claim USDC revenue for claimable batches\n *         User can claim all USDC revenue for claimable batches at once\n *\n * @dev    To reduse complexity, user's revenue requests for batches that are claimable are collects to chainedUsdcRevenue at the user's record\n *         So, each moment user shouldn't have more than 2 BatchedRedemptionRequest: finished but not prepared yet and current\n */\nabstract contract Revenue is LedgerAccessControl, ChainedEventIdCounter, Valor {\n    uint256 internal constant DEFAULT_BATCH_DURATION = 14 days;\n\n    /// @dev Represents amount per chain\n    struct ChainedAmount {\n        uint256 chainId;\n        uint256 amount;\n    }\n\n    struct Batch {\n        /// @dev Admin set this by calling batchPreparedToClaim after provide USDC for batch to the contract\n        bool claimable;\n        /// @dev Total amount of valor, that was redeemed in the batch\n        uint256 redeemedValorAmount;\n        /// @dev When batch finished, current rate will be fixed as the rate for the batch\n        uint256 fixedValorToUsdcRateScaled;\n        /// @dev Total amount of valor, that was redeemed in the batch per chain\n        ChainedAmount[] chainedValorAmount;\n    }\n\n    // Array of batches; batchId is an index in this array\n    Batch[] public batches;\n\n    /// @notice The timestamp when the first batch starts\n    uint256 public batchStartTimestamp;\n\n    struct BatchedRedemptionRequest {\n        uint16 batchId;\n        ChainedAmount[] chainedValorAmount;\n    }\n\n    struct UserRevenueRecord {\n        mapping(uint256 => uint256) chainedUsdcRevenue;\n        BatchedRedemptionRequest[] requests;\n    }\n\n    mapping(address => UserRevenueRecord) internal userRevenue;\n\n    /// @notice Period of the batch in seconds\n    uint256 public batchDuration;\n\n    /* ========== EVENTS ========== */\n\n    /// @notice Emitted when user redeem valor for the chain; batchId is the current batch\n    event ValorRedeemed(uint256 indexed chainEventId, uint256 indexed chainId, address indexed user, uint16 batchId, uint256 valorAmount);\n\n    /// @notice Emitted when user claim collected USDC revenue from chain\n    event UsdcRevenueClaimed(uint256 indexed chainEventId, uint256 indexed chainId, address indexed user, uint256 usdcAmount);\n\n    /// @notice Emitted when admin fixes valor to USDC rate for the batch\n    event BatchValorToUsdcRateIsFixed(uint16 indexed batchId, uint256 fixedValorToUsdcRate);\n\n    /// @notice Emitted when admin marks batch as claimable\n    event BatchPreparedToClaim(uint16 indexed batchId);\n\n    /* ========== ERRORS ========== */\n\n    error RedemptionAmountIsZero();\n    error AmountIsGreaterThanCollectedValor();\n    error BatchIsNotCreatedYet();\n    error BatchIsNotFinished();\n    error BatchValorToUsdcRateIsNotFixed();\n    error NothingToClaim(address user, uint256 chainId);\n    error RedemptionIsNotStartedYet();\n\n    /* ========== INITIALIZER ========== */\n\n    function revenueInit(address, uint256 _batchStartTimstamp, uint256 _batchDuration) internal onlyInitializing {\n        batchStartTimestamp = _batchStartTimstamp;\n        batchDuration = _batchDuration;\n        // create first batch\n        batches.push();\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @notice Calculate and returns the current batch id\n    /// based on the current timestamp, start timestamp and batch duration\n    /// @dev Revert if the redemption is not started yet to prevent redemption before the start\n    function getCurrentBatchId() public view returns (uint16) {\n        uint256 currentTimestamp = block.timestamp;\n        if (currentTimestamp < batchStartTimestamp) revert RedemptionIsNotStartedYet();\n\n        return uint16((currentTimestamp - batchStartTimestamp) / batchDuration);\n    }\n\n    /// @notice Returns the batch structure by id without chained valor amount\n    function getBatchInfo(\n        uint16 _batchId\n    )\n        external\n        view\n        returns (uint256 batchStartTime, uint256 batchEndTime, bool claimable, uint256 redeemedValorAmount, uint256 fixedValorToUsdcRateScaled)\n    {\n        batchStartTime = batchStartTimestamp + _batchId * batchDuration;\n        batchEndTime = batchStartTime + batchDuration;\n        if (_batchId < batches.length) {\n            Batch storage batch = _getBatch(_batchId);\n            claimable = batch.claimable;\n            redeemedValorAmount = batch.redeemedValorAmount;\n            fixedValorToUsdcRateScaled = batch.fixedValorToUsdcRateScaled;\n        } else {\n            claimable = false;\n            redeemedValorAmount = 0;\n            fixedValorToUsdcRateScaled = 0;\n        }\n    }\n\n    /// @notice Returns the amount of valor that user can redeem for the chain\n    function getBatchChainedValorAmount(uint16 _batchId) external view returns (ChainedAmount[] memory) {\n        return _getBatch(_batchId).chainedValorAmount;\n    }\n\n    /// @notice Returns the amount of USDC required for batch on each chain\n    function getUsdcAmountForBatch(uint16 _batchId) external view returns (ChainedAmount[] memory chainedUsdcAmount) {\n        Batch storage batch = _getBatch(_batchId);\n        chainedUsdcAmount = batch.chainedValorAmount;\n        for (uint256 i = 0; i < chainedUsdcAmount.length; i++) {\n            chainedUsdcAmount[i].amount = (chainedUsdcAmount[i].amount * batch.fixedValorToUsdcRateScaled) / VALOR_TO_USDC_RATE_PRECISION;\n        }\n    }\n\n    /// @notice Returns the amount of valor that user redeemed for the chain in the batch\n    function getUserRedeemedValorAmountForBatchAndChain(address _user, uint16 _batchId, uint256 _chainId) external view returns (uint256) {\n        for (uint256 i = 0; i < userRevenue[_user].requests.length; i++) {\n            if (userRevenue[_user].requests[i].batchId == _batchId) {\n                for (uint256 j = 0; j < userRevenue[_user].requests[i].chainedValorAmount.length; j++) {\n                    if (userRevenue[_user].requests[i].chainedValorAmount[j].chainId == _chainId) {\n                        return userRevenue[_user].requests[i].chainedValorAmount[j].amount;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    /// @notice Admin marks batch as claimable when USDC is provided for the batch\n    ///         This also reduce total valor amount and total USDC in treasure\n    ///         This reduce shouldn't affect the valor to USDC rate because valor and USDC amounts are reduced proportionally\n    function batchPreparedToClaim(uint16 _batchId) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_batchId >= getCurrentBatchId()) revert BatchIsNotFinished();\n        Batch storage batch = _getBatch(_batchId);\n        if (batch.fixedValorToUsdcRateScaled == 0) revert BatchValorToUsdcRateIsNotFixed();\n        if (batch.claimable) return;\n\n        totalValorAmount -= batch.redeemedValorAmount;\n        totalUsdcInTreasure -= (batch.redeemedValorAmount * batch.fixedValorToUsdcRateScaled) / VALOR_TO_USDC_RATE_PRECISION;\n        batch.claimable = true;\n\n        emit BatchPreparedToClaim(_batchId);\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /**\n     * @notice Create redemption request for the user to current batch and given chainId\n     *         Can redeem only collected valor, so, before calling this function it supposed that\n     *         _updateValorVarsAndCollectUserValor(_user) from Staking contract were called\n     *         to caclulate and collect pending valor for user\n     *         Also supposed that reentrancy will be checked in the caller function\n     */\n    function _redeemValor(address _user, uint256 _chainId, uint256 _amount) internal whenNotPaused {\n        if (_amount == 0) revert RedemptionAmountIsZero();\n        if (collectedValor[_user] < _amount) revert AmountIsGreaterThanCollectedValor();\n        collectedValor[_user] -= _amount;\n\n        // If user has pending USDC revenue for claimable batch, collect it\n        _collectUserRevenueForClaimableBatch(_user);\n\n        // Update or create redemption request for the user for current batch\n        uint16 currentBatchId = getCurrentBatchId();\n        _getOrCreateBatch(currentBatchId).redeemedValorAmount += _amount;\n        BatchedRedemptionRequest storage request = _getOrCreateBatchedRedemptionRequest(_user, currentBatchId);\n        _getOrCreateChainedAmount(request.chainedValorAmount, _chainId).amount += _amount;\n\n        // Update redeemed valor amount for current batch and chain\n        _getOrCreateChainedAmount(batches[currentBatchId].chainedValorAmount, _chainId).amount += _amount;\n\n        emit ValorRedeemed(_getNextChainedEventId(_chainId), _chainId, _user, currentBatchId, _amount);\n    }\n\n    /**\n     * @notice Claim USDC revenue for the user for the given chainId\n     *         This function first collect USDC revenue for claimable batch\n     *         This function does not transfer USDC to the user, it just returns the amount\n     *         Caller (Ledger contract) should transfer USDC to the user on the Vault chain\n     */\n    function _claimUsdcRevenue(address _user, uint256 _chainId) internal whenNotPaused returns (uint256 claimedUsdcAmount) {\n        // If user has pending USDC revenue for claimable batch, collect it\n        _collectUserRevenueForClaimableBatch(_user);\n\n        claimedUsdcAmount = userRevenue[_user].chainedUsdcRevenue[_chainId];\n        if (claimedUsdcAmount == 0) revert NothingToClaim(_user, _chainId);\n\n        userRevenue[_user].chainedUsdcRevenue[_chainId] = 0;\n\n        emit UsdcRevenueClaimed(_getNextChainedEventId(_chainId), _chainId, _user, claimedUsdcAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice Check if previous finished batch has no fixed valor to USDC rate and fix it\n    ///         batch.fixedValorToUsdcRateScaled will be set to current valorToUsdcRateScaled\n    function _possiblyFixBatchValorToUsdcRateForPreviousBatch() internal whenNotPaused {\n        uint16 curBatchId = getCurrentBatchId();\n        if (curBatchId > 0) {\n            uint16 prevBatchId = curBatchId - 1;\n            // If nobody redeemed valor in the batch, batch will not be created at this moment, let's create it\n            Batch storage prevBatch = _getOrCreateBatch(prevBatchId);\n            if (prevBatch.fixedValorToUsdcRateScaled == 0) {\n                prevBatch.fixedValorToUsdcRateScaled = valorToUsdcRateScaled;\n                emit BatchValorToUsdcRateIsFixed(prevBatchId, prevBatch.fixedValorToUsdcRateScaled);\n            }\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /// @notice Returns the batch by id. Reverts if the batch is not created\n    function _getBatch(uint16 _batchId) private view returns (Batch storage) {\n        if (_batchId >= batches.length) revert BatchIsNotCreatedYet();\n        return batches[_batchId];\n    }\n\n    /// @notice Returns the batch by id. Creates the batch if it is not created yet\n    function _getOrCreateBatch(uint16 _batchId) private returns (Batch storage) {\n        while (_batchId >= batches.length) {\n            batches.push();\n        }\n        return _getBatch(_batchId);\n    }\n\n    /// @notice Returns the redemption request for the user for the batch. Creates the request if it is not created yet\n    function _getOrCreateBatchedRedemptionRequest(address _user, uint16 _batchId) private returns (BatchedRedemptionRequest storage) {\n        for (uint256 i = 0; i < userRevenue[_user].requests.length; i++) {\n            if (userRevenue[_user].requests[i].batchId == _batchId) {\n                return userRevenue[_user].requests[i];\n            }\n        }\n\n        uint256 idx = userRevenue[_user].requests.length;\n        userRevenue[_user].requests.push();\n        userRevenue[_user].requests[idx].batchId = _batchId;\n        return userRevenue[_user].requests[idx];\n    }\n\n    /// @notice Returns the ChainedAmount for the chain. Creates the ChainedAmount if it is not created yet\n    function _getOrCreateChainedAmount(ChainedAmount[] storage _chainedAmounts, uint256 _chainId) private returns (ChainedAmount storage) {\n        for (uint256 i = 0; i < _chainedAmounts.length; i++) {\n            if (_chainedAmounts[i].chainId == _chainId) {\n                return _chainedAmounts[i];\n            }\n        }\n\n        uint256 idx = _chainedAmounts.length;\n        _chainedAmounts.push();\n        _chainedAmounts[idx].chainId = _chainId;\n        return _chainedAmounts[idx];\n    }\n\n    /**\n     * @notice Traverse all user revenue requests and collect USDC revenue for claimable batch\n     *         Suppose that this function will be called each time when user redeem valor or claim USDC\n     *         There shouldn't be more than 3 requests for the user: 2 claimable maximum and current\n     *         Two claimable can happen when user redeem valor for the batch while previous one is in grace period\n     *         and is not claimable yet.\n     *         So, overal complexity is 3 requests to find claimable batch O(1) + chainNum to collect USDC O(N)\n     */\n    function _collectUserRevenueForClaimableBatch(address _user) private {\n        uint256 requestIndex = 0;\n        while (requestIndex < userRevenue[_user].requests.length) {\n            BatchedRedemptionRequest storage request = userRevenue[_user].requests[requestIndex];\n            if (batches[request.batchId].claimable) {\n                // Ok, we found request for claimable batch, let's collect USDC revenue for it\n                for (uint256 chainIndex = 0; chainIndex < request.chainedValorAmount.length; chainIndex++) {\n                    uint256 chainId = request.chainedValorAmount[chainIndex].chainId;\n                    uint256 valorAmount = request.chainedValorAmount[chainIndex].amount;\n                    uint256 usdcAmount = (valorAmount * batches[request.batchId].fixedValorToUsdcRateScaled) / VALOR_TO_USDC_RATE_PRECISION;\n                    userRevenue[_user].chainedUsdcRevenue[chainId] += usdcAmount;\n                }\n                // Now we can remove this request\n                uint256 lastIndex = userRevenue[_user].requests.length - 1;\n                userRevenue[_user].requests[requestIndex] = userRevenue[_user].requests[lastIndex];\n                userRevenue[_user].requests.pop();\n            } else {\n                requestIndex++;\n            }\n        }\n    }\n\n    // gap for upgradeable\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/Signature.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {LedgerSignedTypes} from \"./LedgerTypes.sol\";\n\n/**\n * @title Signature library\n * @author Orderly Network\n * @notice Check signatures for messages\n */\nlibrary Signature {\n    error InvalidSignature();\n\n    function verify(bytes32 hash, bytes32 r, bytes32 s, uint8 v, address signer) internal pure {\n        if (ECDSA.recover(hash, v, r, s) != signer) revert InvalidSignature();\n    }\n\n    function verifyUintValueSignature(LedgerSignedTypes.UintValueData memory data, address signer) internal pure {\n        verify(MessageHashUtils.toEthSignedMessageHash(keccak256(abi.encode(data.value, data.timestamp))), data.r, data.s, data.v, signer);\n    }\n}\n"
    },
    "contracts/lib/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerToken} from \"./OCCTypes.sol\";\nimport {LedgerAccessControl} from \"./LedgerAccessControl.sol\";\nimport {ChainedEventIdCounter} from \"./ChainedEventIdCounter.sol\";\nimport {Valor} from \"./Valor.sol\";\n\n/**\n * @title Staking\n * @author Orderly Network\n * @notice Staking $ORDER and es$ORDER (record based) tokens to earn valor\n * Only $ORDER and es$ORDER tokens can be staked\n * Staked $ORDER and es$ORDER counts separately in StakingInfo but have equal weight in calculation of valor\n * User can unstake es$ORDER tokens immediately. Unstaked es$ORDER tokens will be vested to $ORDER in Vesting contract by Ledger contract\n * User can unstake $ORDER tokens after `unstakeLockPeriod` time (7 days by default) to de-incentivize unstaking\n * User have only one unstaking request for $ORDER at a time. Repeated unstake operations increase unstaking amounts but reset unlockTimestamp for whole unstaking.\n * After `unstakeLockPeriod` user can withdraw $ORDER tokens to his wallet on the Vault chain\n * User can cancel unstaking request for $ORDER any time. In this case amounts of $ORDER, that pending for unstake immediately adds to stakind amount and become count in valor calculation again.\n * When user make unstaking, amounts of $ORDER and es$ORDER, that pending for unstake, immediately subtract from staking amount and does not count in valor calculation.\n */\nabstract contract Staking is LedgerAccessControl, ChainedEventIdCounter, Valor {\n    uint256 internal constant DEFAULT_UNSTAKE_LOCK_PERIOD = 7 days;\n    uint256 internal constant ACC_VALOR_PER_SHARE_PRECISION = 1e18;\n\n    struct StakingInfo {\n        uint256[2] balance; // Amount of staken $ORDER and es$ORDER\n        uint256 valorDebt; // Amount of valor, that was already claimed by user\n    }\n\n    mapping(address => StakingInfo) private userStakingInfo;\n\n    struct PendingUnstake {\n        uint256 balanceOrder; // Amount of unstaked $ORDER; es$ORDER unstake immediately\n        uint256 unlockTimestamp; // Timestamp (block.timestamp) when unstaking amount will be unlocked\n    }\n\n    mapping(address => PendingUnstake) public userPendingUnstake;\n\n    /// Total amount of staken $ORDER and es$ORDER\n    uint256 public totalStakedAmount;\n\n    /// @notice The last time that the valor variables were updated\n    uint256 public lastValorUpdateTimestamp;\n\n    /// @notice The accrued valor share, scaled to `ACC_VALOR_PER_SHARE_PRECISION`\n    uint256 public accValorPerShareScaled;\n\n    /// @notice Period of time, that user have to wait after unstake request, before he can withdraw tokens\n    uint256 public unstakeLockPeriod;\n\n    /* ========== EVENTS ========== */\n\n    /// @notice Emitted when user stakes $ORDER or es$ORDER tokens\n    event Staked(uint256 indexed chainedEventId, uint256 indexed chainId, address indexed staker, uint256 amount, LedgerToken token);\n\n    /// @notice Emitted when user requests unstake $ORDER tokens\n    event OrderUnstakeRequested(uint256 indexed chainedEventId, uint256 indexed chainId, address indexed staker, uint256 amount);\n\n    /// @notice Emitted when user cancels unstake $ORDER tokens request\n    event OrderUnstakeCancelled(uint256 indexed chainedEventId, uint256 indexed chainId, address indexed staker, uint256 pendingOrderAmount);\n\n    /// @notice Emitted when user withdraws $ORDER tokens\n    event OrderWithdrawn(uint256 indexed chainedEventId, uint256 indexed chainId, address indexed staker, uint256 amount);\n\n    /// @notice Emitted when user unstakes es$ORDER tokens\n    event EsOrderUnstake(uint256 indexed chainedEventId, uint256 indexed chainId, address indexed staker, uint256 amount);\n\n    /// @notice Emitted for _createOrderUnstakeRequest, _cancelOrderUnstakeRequest and _withdrawOrder functions\n    event OrderUnstakeAmount(address indexed staker, uint256 totalUnstakedAmount, uint256 unlockTimestamp);\n\n    /* ========== ERRORS ========== */\n\n    error UnsupportedToken();\n    error AmountIsZero();\n    error StakingBalanceInsufficient(LedgerToken token);\n    error NoPendingUnstakeRequest();\n    error UnlockTimeNotPassedYet();\n\n    /* ========== INITIALIZER ========== */\n\n    function stakingInit(address, uint256 _unstakeLockPeriod) internal onlyInitializing {\n        unstakeLockPeriod = _unstakeLockPeriod;\n        lastValorUpdateTimestamp = block.timestamp;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @notice Get the staking balances for a given _user\n    function getStakingInfo(address _user) external view returns (uint256 orderBalance, uint256 esOrderBalance) {\n        return (userStakingInfo[_user].balance[uint256(LedgerToken.ORDER)], userStakingInfo[_user].balance[uint256(LedgerToken.ESORDER)]);\n    }\n\n    /// @notice Get the total amount of $ORDER and es$ORDER staked by `_user`\n    function userTotalStakingBalance(address _user) public view returns (uint256) {\n        return userStakingInfo[_user].balance[uint256(LedgerToken.ORDER)] + userStakingInfo[_user].balance[uint256(LedgerToken.ESORDER)];\n    }\n\n    /// @notice Get the amount of $ORDER ready to be withdrawn by `_user`\n    function getOrderAvailableToWithdraw(address _user) external view returns (uint256 orderAmount) {\n        PendingUnstake storage pendingUnstake = userPendingUnstake[_user];\n        if (pendingUnstake.unlockTimestamp == 0 || block.timestamp < pendingUnstake.unlockTimestamp) {\n            return 0;\n        }\n\n        orderAmount = pendingUnstake.balanceOrder;\n    }\n\n    /// @notice Get the pending amount of valor up to now for a given _user\n    function getUserValor(address _user) external view returns (uint256) {\n        return _getPendingValor(_user) + collectedValor[_user];\n    }\n\n    /// @notice Calculate and update valor per share changed over time\n    /// This function actually emits valor to users\n    function updateValorVars() public whenNotPaused {\n        if (block.timestamp > lastValorUpdateTimestamp) {\n            (uint256 accValorPerShareCurrentScaled, uint256 valorEmission) = _getCurrentAccValorPreShareScaled();\n            accValorPerShareScaled = accValorPerShareCurrentScaled;\n            totalValorEmitted += valorEmission;\n            totalValorAmount += valorEmission;\n            lastValorUpdateTimestamp = block.timestamp;\n        }\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /// @notice Stake tokens from LedgerToken list for a given user\n    /// For now only $ORDER and es$ORDER tokens are supported\n    function _stake(address _user, uint256 _chainId, LedgerToken _token, uint256 _amount) internal nonReentrant whenNotPaused {\n        if (_amount == 0) revert AmountIsZero();\n        if (_token > LedgerToken.ESORDER) revert UnsupportedToken();\n\n        _updateValorVarsAndCollectUserValor(_user);\n\n        userStakingInfo[_user].balance[uint256(_token)] += _amount;\n        userStakingInfo[_user].valorDebt = _getUserTotalValorDebt(_user);\n        totalStakedAmount += _amount;\n\n        emit Staked(_getNextChainedEventId(_chainId), _chainId, _user, _amount, _token);\n    }\n\n    /// @notice Create unstaking request for `_amount` of $ORDER tokens\n    /// If user has unstaking request, then it's amount will be updated but unlock time will reset to `unstakeLockPeriod` from now\n    function _createOrderUnstakeRequest(address _user, uint256 _chainId, uint256 _amount) internal nonReentrant whenNotPaused {\n        if (_amount == 0) revert AmountIsZero();\n\n        if (userStakingInfo[_user].balance[uint256(LedgerToken.ORDER)] < _amount) revert StakingBalanceInsufficient(LedgerToken.ORDER);\n\n        _updateValorVarsAndCollectUserValor(_user);\n\n        userStakingInfo[_user].balance[uint256(LedgerToken.ORDER)] -= _amount;\n        userStakingInfo[_user].valorDebt = _getUserTotalValorDebt(_user);\n        totalStakedAmount -= _amount;\n        userPendingUnstake[_user].balanceOrder += _amount;\n        userPendingUnstake[_user].unlockTimestamp = block.timestamp + unstakeLockPeriod;\n\n        emit OrderUnstakeRequested(_getNextChainedEventId(_chainId), _chainId, _user, _amount);\n        emit OrderUnstakeAmount(_user, userPendingUnstake[_user].balanceOrder, userPendingUnstake[_user].unlockTimestamp);\n    }\n\n    /// @notice Cancel unstaking request for $ORDER tokens and re-stake them\n    function _cancelOrderUnstakeRequest(address _user, uint256 _chainId) internal nonReentrant whenNotPaused returns (uint256 pendingOrderAmount) {\n        if (userPendingUnstake[_user].unlockTimestamp == 0) revert NoPendingUnstakeRequest();\n\n        _updateValorVarsAndCollectUserValor(_user);\n\n        pendingOrderAmount = userPendingUnstake[_user].balanceOrder;\n\n        userStakingInfo[_user].balance[uint256(LedgerToken.ORDER)] += pendingOrderAmount;\n        userStakingInfo[_user].valorDebt = _getUserTotalValorDebt(_user);\n        totalStakedAmount += pendingOrderAmount;\n\n        emit OrderUnstakeCancelled(_getNextChainedEventId(_chainId), _chainId, _user, pendingOrderAmount);\n\n        userPendingUnstake[_user].balanceOrder = 0;\n        userPendingUnstake[_user].unlockTimestamp = 0;\n        emit OrderUnstakeAmount(_user, 0, 0);\n    }\n\n    /// @notice Withdraw unstaked $ORDER tokens. Contract does not tansfer tokens to user, it just returns amount of tokens to Ledger\n    /// Caller (Ledger contract) should transfer tokens to user\n    function _withdrawOrder(address _user, uint256 _chainId) internal nonReentrant whenNotPaused returns (uint256 orderAmountForWithdraw) {\n        if (userPendingUnstake[_user].unlockTimestamp == 0) revert NoPendingUnstakeRequest();\n        if (block.timestamp < userPendingUnstake[_user].unlockTimestamp) revert UnlockTimeNotPassedYet();\n\n        orderAmountForWithdraw = userPendingUnstake[_user].balanceOrder;\n        if (orderAmountForWithdraw > 0) {\n            emit OrderWithdrawn(_getNextChainedEventId(_chainId), _chainId, _user, orderAmountForWithdraw);\n\n            userPendingUnstake[_user].balanceOrder = 0;\n            userPendingUnstake[_user].unlockTimestamp = 0;\n            emit OrderUnstakeAmount(_user, 0, 0);\n        }\n    }\n\n    /// @notice Unstake es$ORDER tokens immediately.\n    /// Caller (Ledger contract) should vest _amount of es$ORDER tokens to Vesting contract\n    function _esOrderUnstake(address _user, uint256 _chainId, uint256 _amount) internal nonReentrant whenNotPaused {\n        if (_amount == 0) revert AmountIsZero();\n\n        if (userStakingInfo[_user].balance[uint256(LedgerToken.ESORDER)] < _amount) revert StakingBalanceInsufficient(LedgerToken.ESORDER);\n\n        _updateValorVarsAndCollectUserValor(_user);\n\n        userStakingInfo[_user].balance[uint256(LedgerToken.ESORDER)] -= _amount;\n        userStakingInfo[_user].valorDebt = _getUserTotalValorDebt(_user);\n        totalStakedAmount -= _amount;\n\n        emit EsOrderUnstake(_getNextChainedEventId(_chainId), _chainId, _user, _amount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice Convert pending valor to collected valor for user\n    /// Should be called before any operation with user balance:\n    /// stake, unstake, cancel unstake, redeem valor\n    function _updateValorVarsAndCollectUserValor(address _user) internal {\n        updateValorVars();\n\n        uint256 pendingValor = _getPendingValor(_user);\n        if (pendingValor > 0) {\n            userStakingInfo[_user].valorDebt += pendingValor;\n            collectedValor[_user] += pendingValor;\n        }\n    }\n\n    /// @notice Get the pending amount of valor for a given user\n    function _getPendingValor(address _user) private view returns (uint256) {\n        return _getUserTotalValorDebt(_user) - userStakingInfo[_user].valorDebt;\n    }\n\n    /// @notice Get the total amount of valor debt for a given user\n    function _getUserTotalValorDebt(address _user) private view returns (uint256) {\n        (uint256 accValorPerShareCurrentScaled, ) = _getCurrentAccValorPreShareScaled();\n        return (userTotalStakingBalance(_user) * accValorPerShareCurrentScaled) / ACC_VALOR_PER_SHARE_PRECISION;\n    }\n\n    /// @notice Get current accrued valor share, updated to the current block\n    /// This function calculates valor emission up to now but does not actually emit valor\n    function _getCurrentAccValorPreShareScaled() private view returns (uint256 accValorPerShareCurrentScaled, uint256 valorEmission) {\n        if (block.timestamp <= lastValorUpdateTimestamp || totalStakedAmount == 0) {\n            return (accValorPerShareScaled, 0);\n        }\n\n        accValorPerShareCurrentScaled = accValorPerShareScaled;\n        uint256 secondsElapsed = block.timestamp - lastValorUpdateTimestamp;\n        valorEmission = secondsElapsed * valorPerSecond;\n        if (totalValorEmitted + valorEmission > maximumValorEmission) {\n            valorEmission = maximumValorEmission - totalValorEmitted;\n        }\n        accValorPerShareCurrentScaled += ((valorEmission * ACC_VALOR_PER_SHARE_PRECISION) / totalStakedAmount);\n    }\n\n    // gap for upgradeable\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/Valor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerAccessControl} from \"./LedgerAccessControl.sol\";\nimport {LedgerSignedTypes} from \"./LedgerTypes.sol\";\nimport {Signature} from \"./Signature.sol\";\n\n/**\n * @title Valor contract\n * @author Orderly Network\n * @notice Manage the valor (a kind of internal token)\n *         User obtains valor by staking $ORDER and es$ORDER tokens\n *         Valor is emmitted over time, based on the valorPerSecond rate\n *         Valor can be redeemed for USDC in the Redemption contract\n *         Valor's rate to USDC is updated daily when TREASURE_UPDATER_ROLE calls dailyUsdcNetFeeRevenue\n *         Contract is source of truth for total totalValorAmount, totalUsdcInTreasure, valorToUsdcRateScaled\n */\nabstract contract Valor is LedgerAccessControl {\n    uint256 public constant VALOR_TO_USDC_RATE_PRECISION = 1e27;\n\n    /// @notice The role, that is allowed to update USDC net fee revenue\n    bytes32 public constant TREASURE_UPDATER_ROLE = keccak256(\"TREASURE_UPDATER_ROLE\");\n\n    /// @notice The amount of valor token, that will be emitted per second\n    uint256 public valorPerSecond;\n\n    /// @notice The maximum amount of valor token, that can be emitted\n    uint256 public maximumValorEmission;\n\n    /// @notice The total amount of valor token, that has been emitted\n    uint256 public totalValorEmitted;\n\n    /// @notice The total amount of valor token, that is currently in circulation\n    uint256 public totalValorAmount;\n\n    /// @notice The timestamp of the last update of the USDC net fee revenue\n    uint256 public lastUsdcNetFeeRevenueUpdateTimestamp;\n\n    /// @notice The total amount of USDC, that has been collected in the treasure\n    uint256 public totalUsdcInTreasure;\n\n    /// @notice The current rate of valor to USDC\n    uint256 public valorToUsdcRateScaled;\n\n    /// @notice The amount of valor token, that has been collected by the user\n    mapping(address => uint256) public collectedValor;\n\n    /// @notice The address, that signed the USDC revenue updates\n    address public usdcUpdaterAddress;\n\n    /* ========== EVENTS ========== */\n\n    /// @notice Emmited, when the daily USDC net fee revenue has been updated\n    event DailyUsdcNetFeeRevenueUpdated(\n        uint256 indexed timestamp,\n        uint256 usdcNetFeeRevenue,\n        uint256 totalUsdcInTreasure,\n        uint256 totalValorAmount,\n        uint256 valorToUsdcRateScaled\n    );\n\n    event TotalUsdcInTreasureUpdated(uint256 totalUsdcInTreasure, uint256 totalValorAmount, uint256 valorToUsdcRateScaled);\n\n    /* ========== ERRORS ========== */\n    error ValorPerSecondExceedsMaxValue();\n    error TooEarlyUsdcNetFeeRevenueUpdate();\n\n    /* ========== INITIALIZER ========== */\n\n    function valorInit(address _owner, uint256 _valorPerSecond, uint256 _maximumValorEmission) internal onlyInitializing {\n        _grantRole(TREASURE_UPDATER_ROLE, _owner);\n\n        valorPerSecond = _valorPerSecond;\n        maximumValorEmission = _maximumValorEmission;\n    }\n\n    /// @notice Owner can set address, that signed the USDC revenue updates\n    function setUsdcUpdaterAddress(address _usdcUpdaterAddress) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        usdcUpdaterAddress = _usdcUpdaterAddress;\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    /**\n     * @notice Set the totalUsdcInTreasure. Restricted to DEFAULT_ADMIN_ROLE\n     *          Function updates the totalUsdcInTreasure, valorToUsdcRateScaled\n     */\n    function setTotalUsdcInTreasure(uint256 _totalUsdcInTreasure) external whenNotPaused onlyRole(DEFAULT_ADMIN_ROLE) {\n        totalUsdcInTreasure = _totalUsdcInTreasure;\n        _updateValorToUsdcRateScaled();\n        emit TotalUsdcInTreasureUpdated(totalUsdcInTreasure, totalValorAmount, valorToUsdcRateScaled);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n    /**\n     * @notice CeFi updates the daily USDC net fee revenue\n     *          Function reverts, if the function is called too early - less than 12 hours after the last update\n     *          to prevent accidental double updates\n     *          Function updates the totalUsdcInTreasure, valorToUsdcRateScaled\n     *          Supposed to be called from the Ledger contract\n     */\n    function _dailyUsdcNetFeeRevenue(LedgerSignedTypes.UintValueData calldata data) internal whenNotPaused onlyRole(TREASURE_UPDATER_ROLE) {\n        if (block.timestamp < lastUsdcNetFeeRevenueUpdateTimestamp + 12 hours) revert TooEarlyUsdcNetFeeRevenueUpdate();\n\n        Signature.verifyUintValueSignature(data, usdcUpdaterAddress);\n\n        lastUsdcNetFeeRevenueUpdateTimestamp = block.timestamp;\n        totalUsdcInTreasure += data.value;\n        _updateValorToUsdcRateScaled();\n        emit DailyUsdcNetFeeRevenueUpdated(data.timestamp, data.value, totalUsdcInTreasure, totalValorAmount, valorToUsdcRateScaled);\n    }\n\n    function _updateValorToUsdcRateScaled() internal {\n        valorToUsdcRateScaled = totalValorAmount == 0 ? 0 : (totalUsdcInTreasure * VALOR_TO_USDC_RATE_PRECISION) / totalValorAmount;\n    }\n\n    // gap for upgradeable\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerToken} from \"./OCCTypes.sol\";\nimport {LedgerAccessControl} from \"./LedgerAccessControl.sol\";\nimport {ChainedEventIdCounter} from \"./ChainedEventIdCounter.sol\";\nimport {Staking} from \"./Staking.sol\";\n\n/**\n * @title Vesting\n * @author Orderly Network\n * @notice Vesting es$ORDER to $ORDER tokens\n * Full vesting period is 90 days and it is divided into two parts:\n * 1. Lock period - 15 days\n * 2. Linear period - 75 days\n * During lock period user can not withdraw vested $ORDER tokens\n * During linear period vested $ORDER tokens amount linearly increase from 50% to 100%\n * User can create multiple vesting requests\n * User can cancel vesting request and stake back es$ORDER tokens\n * Unvested amount of $ORDER tokens will be collected by orderCollector\n */\nabstract contract Vesting is LedgerAccessControl, ChainedEventIdCounter {\n    uint256 internal constant VESTING_LOCK_PERIOD = 15 days;\n    uint256 internal constant VESTING_LINEAR_PERIOD = 75 days;\n\n    struct VestingRequest {\n        uint256 requestId;\n        uint256 esOrderAmount; // Amount of es$ORDER tokens for vesting\n        uint256 unlockTimestamp; // Timestamp (block.timestamp) when vested amount will be unlocked\n    }\n\n    struct UserVestingInfo {\n        uint256 currentRequestId;\n        VestingRequest[] requests;\n    }\n\n    mapping(address => UserVestingInfo) private userVestingInfos;\n\n    /// @notice Lock period where user can not withdraw vested $ORDER\n    uint256 public vestingLockPeriod;\n\n    /// @notice Period after lock period, during which vesting $ORDER amount linearly increase from 50% to 100%\n    uint256 public vestingLinearPeriod;\n\n    /* ========== EVENTS ========== */\n    event VestingRequested(\n        uint256 indexed chainEventId,\n        uint256 indexed chainId,\n        address indexed user,\n        uint256 requestId,\n        uint256 amountEsorderRequested,\n        uint256 unlockTimestamp\n    );\n    event VestingCanceled(\n        uint256 indexed chainEventId,\n        uint256 indexed chainId,\n        address indexed user,\n        uint256 requestId,\n        uint256 amountEsorderStakedBack\n    );\n    event VestingClaimed(\n        uint256 indexed chainEventId,\n        uint256 indexed chainId,\n        address indexed user,\n        uint256 requestId,\n        uint256 amountEsorderBurned,\n        uint256 amountOrderVested,\n        uint256 vestedPeriod\n    );\n\n    /* ========== ERRORS ========== */\n\n    error VestingLockPeriodIsZero();\n    error VestingLinearPeriodIsZero();\n    error VestingAmountIsZero();\n    error VestingPeriodIsOutOfRange();\n    error UserDontHaveVestingRequest(address _user, uint256 _requestId);\n    error VestingLockPeriodNotPassed();\n    error DepositNotEnough(uint256 amountEsorderDeposited, uint256 amountEsorderRequested);\n\n    /* ========== INITIALIZER ========== */\n    function vestingInit(address, uint256 _vestingLockPeriod, uint256 _vestingLinearPeriod) internal onlyInitializing {\n        if (_vestingLockPeriod == 0) revert VestingLockPeriodIsZero();\n        if (_vestingLinearPeriod == 0) revert VestingLinearPeriodIsZero();\n\n        vestingLockPeriod = _vestingLockPeriod;\n        vestingLinearPeriod = _vestingLinearPeriod;\n    }\n\n    /* ========== PUBLIC VIEW FUNCTIONS ========== */\n    /// @notice Return amount of $ORDER tokens for withdraw at the moment\n    /// @param _user User address\n    function calculateVestingOrderAmount(address _user, uint256 _requestId) public view returns (uint256) {\n        return _calculateVestingOrderAmount(_findVestingRequest(_user, _requestId));\n    }\n\n    function getUserVestingRequests(address _user) public view returns (VestingRequest[] memory) {\n        return userVestingInfos[_user].requests;\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    /// @notice Create vesting request for user\n    /// This call suppose to be called from Ledger contract only as part of es$ORDER unstake and vest!\n    /// It does not check if user has enough es$ORDERs - it should be checked in Ledger contract as part of es$ORDER unstake.\n    function _createVestingRequest(address _user, uint256 _chainId, uint256 _amountEsorder) internal whenNotPaused nonReentrant {\n        if (_amountEsorder == 0) revert VestingAmountIsZero();\n\n        UserVestingInfo storage vestingInfo = userVestingInfos[_user];\n\n        VestingRequest memory vestingRequest = VestingRequest(vestingInfo.currentRequestId, _amountEsorder, block.timestamp + vestingLockPeriod);\n        vestingInfo.requests.push(vestingRequest);\n        vestingInfo.currentRequestId++;\n\n        emit VestingRequested(\n            _getNextChainedEventId(_chainId),\n            _chainId,\n            _user,\n            vestingRequest.requestId,\n            _amountEsorder,\n            vestingRequest.unlockTimestamp\n        );\n    }\n\n    /// @notice Cancel vesting request for user and return es$ORDER amount\n    /// Caller should stake back es$ORDER tokens\n    function _cancelVestingRequest(\n        address _user,\n        uint256 _chainId,\n        uint256 _requestId\n    ) internal whenNotPaused nonReentrant returns (uint256 esOrderAmountToStakeBack) {\n        VestingRequest storage userVestingRequest = _findVestingRequest(_user, _requestId);\n\n        esOrderAmountToStakeBack = userVestingRequest.esOrderAmount;\n        _removeUserVestingRequest(_user, userVestingRequest);\n\n        emit VestingCanceled(_getNextChainedEventId(_chainId), _chainId, _user, _requestId, esOrderAmountToStakeBack);\n    }\n\n    /// @notice Cancel all vesting requests for user\n    /// Caller should stake back es$ORDER tokens\n    function _cancelAllVestingRequests(\n        address _user,\n        uint256 _chainId\n    ) internal whenNotPaused nonReentrant returns (uint256 esOrderAmountToStakeBack) {\n        UserVestingInfo memory userVestingInfo = userVestingInfos[_user];\n\n        for (uint256 i = 0; i < userVestingInfo.requests.length; i++) {\n            uint256 esOrderAmount = userVestingInfo.requests[i].esOrderAmount;\n            esOrderAmountToStakeBack += esOrderAmount;\n\n            emit VestingCanceled(_getNextChainedEventId(_chainId), _chainId, _user, userVestingInfo.requests[i].requestId, esOrderAmount);\n        }\n\n        delete userVestingInfos[_user];\n    }\n\n    /// @notice Withdraw $ORDER tokens for user\n    /// @dev User can withdraw $ORDER tokens only after locking period passed\n    function _claimVestingRequest(\n        address _user,\n        uint256 _chainId,\n        uint256 _requestId\n    ) internal whenNotPaused nonReentrant returns (uint256 claimedOrderAmount, uint256 unclaimedOrderAmount) {\n        VestingRequest storage userVestingRequest = _findVestingRequest(_user, _requestId);\n\n        if (block.timestamp < userVestingRequest.unlockTimestamp) revert VestingLockPeriodNotPassed();\n\n        claimedOrderAmount = _calculateVestingOrderAmount(userVestingRequest);\n        unclaimedOrderAmount = userVestingRequest.esOrderAmount - claimedOrderAmount;\n\n        emit VestingClaimed(\n            _getNextChainedEventId(_chainId),\n            _chainId,\n            _user,\n            _requestId,\n            userVestingRequest.esOrderAmount,\n            claimedOrderAmount,\n            block.timestamp - userVestingRequest.unlockTimestamp\n        );\n\n        _removeUserVestingRequest(_user, userVestingRequest);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /// @notice Find a vesting request for a user by request ID\n    function _findVestingRequest(address _user, uint256 _requestId) internal view returns (VestingRequest storage) {\n        for (uint256 i = 0; i < userVestingInfos[_user].requests.length; i++) {\n            if (userVestingInfos[_user].requests[i].requestId == _requestId) {\n                return userVestingInfos[_user].requests[i];\n            }\n        }\n        revert UserDontHaveVestingRequest(_user, _requestId);\n    }\n\n    /// @notice Calculate amount of $ORDER tokens for withdraw\n    /// @dev 15 days vesting period - 50% of es$ORDER tokens amount\n    /// @dev 90 days vesting period - 100% of es$ORDER tokens amount\n    function _calculateVestingOrderAmount(VestingRequest memory _vestingRequest) private view returns (uint256) {\n        if (_vestingRequest.esOrderAmount == 0 || block.timestamp < _vestingRequest.unlockTimestamp) {\n            return 0;\n        }\n\n        uint256 vestedTime = block.timestamp - _vestingRequest.unlockTimestamp;\n        if (vestedTime > vestingLinearPeriod) vestedTime = vestingLinearPeriod;\n        return _vestingRequest.esOrderAmount / 2 + (_vestingRequest.esOrderAmount * vestedTime) / vestingLinearPeriod / 2;\n    }\n\n    function _removeUserVestingRequest(address _user, VestingRequest storage userVestingRequest) private {\n        VestingRequest memory lastRequest = userVestingInfos[_user].requests[userVestingInfos[_user].requests.length - 1];\n        userVestingRequest.requestId = lastRequest.requestId;\n        userVestingRequest.esOrderAmount = lastRequest.esOrderAmount;\n        userVestingRequest.unlockTimestamp = lastRequest.unlockTimestamp;\n        userVestingInfos[_user].requests.pop();\n    }\n\n    // gap for upgradeable\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/OmnichainLedgerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {IOFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {LedgerAccessControl} from \"./lib/LedgerAccessControl.sol\";\nimport {ChainedEventIdCounter} from \"./lib/ChainedEventIdCounter.sol\";\nimport {LedgerPayloadTypes, PayloadDataType, LedgerSignedTypes} from \"./lib/LedgerTypes.sol\";\nimport {Valor} from \"./lib/Valor.sol\";\nimport {Staking} from \"./lib/Staking.sol\";\nimport {Vesting} from \"./lib/Vesting.sol\";\nimport {Revenue} from \"./lib/Revenue.sol\";\nimport {MerkleDistributor} from \"./lib/MerkleDistributor.sol\";\nimport {OCCVaultMessage, OCCLedgerMessage, LedgerToken} from \"./lib/OCCTypes.sol\";\nimport {ILedgerOCCManager} from \"./lib/ILedgerOCCManager.sol\";\n\n// lz imports\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\n\ncontract OmnichainLedgerV1 is LedgerAccessControl, UUPSUpgradeable, ChainedEventIdCounter, MerkleDistributor, Valor, Staking, Revenue, Vesting {\n    /* ========== STATE VARIABLES ========== */\n    address public occAdaptor;\n\n    /* ========== ERRORS ========== */\n    error UnsupportedPayloadType();\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyOCCAdaptor() {\n        require(msg.sender == occAdaptor, \"OnlyOCCAdaptor\");\n        _;\n    }\n\n    function VERSION() external pure virtual returns (string memory) {\n        return \"1.0.0\";\n    }\n\n    /* ====== UUPS ATHORIZATION ====== */\n\n    /// @notice upgrade the contract\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(address _owner, address _occAdaptor, uint256 _valorPerSecond, uint256 _maximumValorEmission) external initializer {\n        ledgerAccessControlInit(_owner);\n        merkleDistributorInit(_owner);\n        valorInit(_owner, _valorPerSecond, _maximumValorEmission);\n        stakingInit(_owner, DEFAULT_UNSTAKE_LOCK_PERIOD);\n        revenueInit(_owner, block.timestamp, DEFAULT_BATCH_DURATION);\n        vestingInit(_owner, VESTING_LOCK_PERIOD, VESTING_LINEAR_PERIOD);\n\n        occAdaptor = _occAdaptor;\n    }\n\n    /* ========== OWNER FUNCTIONS ========== */\n\n    function setOccAdaptor(address _occAdaptor) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        occAdaptor = _occAdaptor;\n    }\n\n    /* ========== EXTERNAL FUNCTIONS ========== */\n\n    /// @notice Receives message from OCCAdapter and dispatch it\n    function ledgerRecvFromVault(OCCVaultMessage memory message) external onlyOCCAdaptor {\n        // ========== ClaimReward ==========\n        if (message.payloadType == uint8(PayloadDataType.ClaimReward)) {\n            LedgerPayloadTypes.ClaimReward memory claimRewardPayload = abi.decode(message.payload, (LedgerPayloadTypes.ClaimReward));\n            _ledgerClaimRewards(\n                claimRewardPayload.distributionId,\n                message.sender,\n                message.srcChainId,\n                claimRewardPayload.cumulativeAmount,\n                claimRewardPayload.merkleProof\n            );\n        }\n        // ========== Stake ==========\n        else if (message.payloadType == uint8(PayloadDataType.Stake)) {\n            _stake(message.sender, message.srcChainId, message.token, message.tokenAmount);\n        }\n        // ========== CreateOrderUnstakeRequest ==========\n        else if (message.payloadType == uint8(PayloadDataType.CreateOrderUnstakeRequest)) {\n            LedgerPayloadTypes.CreateOrderUnstakeRequest memory createOrderUnstakeRequestPayload = abi.decode(\n                message.payload,\n                (LedgerPayloadTypes.CreateOrderUnstakeRequest)\n            );\n            _createOrderUnstakeRequest(message.sender, message.srcChainId, createOrderUnstakeRequestPayload.amount);\n        }\n        // ========== CancelOrderUnstakeRequest ==========\n        else if (message.payloadType == uint8(PayloadDataType.CancelOrderUnstakeRequest)) {\n            _cancelOrderUnstakeRequest(message.sender, message.srcChainId);\n        }\n        // ========== WithdrawOrder ==========\n        else if (message.payloadType == uint8(PayloadDataType.WithdrawOrder)) {\n            _ledgerWithdrawOrder(message.sender, message.srcChainId);\n        }\n        // ========== EsOrderUnstakeAndVest ==========\n        else if (message.payloadType == uint8(PayloadDataType.EsOrderUnstakeAndVest)) {\n            LedgerPayloadTypes.EsOrderUnstakeAndVest memory esOrderUnstakeAndVestPayload = abi.decode(\n                message.payload,\n                (LedgerPayloadTypes.EsOrderUnstakeAndVest)\n            );\n            _ledgerEsOrderUnstakeAndVest(message.sender, message.srcChainId, esOrderUnstakeAndVestPayload.amount);\n        }\n        // ========== CancelVestingRequest ==========\n        else if (message.payloadType == uint8(PayloadDataType.CancelVestingRequest)) {\n            LedgerPayloadTypes.CancelVestingRequest memory cancelVestingRequestPayload = abi.decode(\n                message.payload,\n                (LedgerPayloadTypes.CancelVestingRequest)\n            );\n            uint256 esOrderAmountToReStake = _cancelVestingRequest(message.sender, message.srcChainId, cancelVestingRequestPayload.requestId);\n            _stake(message.sender, message.srcChainId, LedgerToken.ESORDER, esOrderAmountToReStake);\n        }\n        // ========== CancelAllVestingRequests ==========\n        else if (message.payloadType == uint8(PayloadDataType.CancelAllVestingRequests)) {\n            uint256 esOrderAmountToReStake = _cancelAllVestingRequests(message.sender, message.srcChainId);\n            _stake(message.sender, message.srcChainId, LedgerToken.ESORDER, esOrderAmountToReStake);\n        }\n        // ========== ClaimVestingRequest ==========\n        else if (message.payloadType == uint8(PayloadDataType.ClaimVestingRequest)) {\n            LedgerPayloadTypes.ClaimVestingRequest memory claimVestingRequestPayload = abi.decode(\n                message.payload,\n                (LedgerPayloadTypes.ClaimVestingRequest)\n            );\n            _ledgerClaimVestingRequest(message.sender, message.srcChainId, claimVestingRequestPayload.requestId);\n        }\n        // ========== RedeemValor ==========\n        else if (message.payloadType == uint8(PayloadDataType.RedeemValor)) {\n            LedgerPayloadTypes.RedeemValor memory redeemValorPayload = abi.decode(message.payload, (LedgerPayloadTypes.RedeemValor));\n            _ledgerRedeemValor(message.sender, message.srcChainId, redeemValorPayload.amount);\n        }\n        // ========== ClaimUsdcRevenue ==========\n        else if (message.payloadType == uint8(PayloadDataType.ClaimUsdcRevenue)) {\n            // _claimUsdcRevenue(message.sender, message.srcChainId);\n            _ledgerClaimUsdcRevenue(message.sender, message.srcChainId);\n        }\n        // ========== UnsupportedPayloadType ==========\n        else {\n            revert UnsupportedPayloadType();\n        }\n    }\n\n    /// @notice CeFi updates the daily USDC net fee revenue, define\n    /// Then check if it was last day in batch, and if so, fix this price for the batch\n    /// Internally restricted to TREASURE_UPDATER_ROLE\n    function dailyUsdcNetFeeRevenue(LedgerSignedTypes.UintValueData calldata data) external {\n        _dailyUsdcNetFeeRevenue(data);\n        _possiblyFixBatchValorToUsdcRateForPreviousBatch();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice Implement internal reward claiming logic:\n    /// $ORDER rewards are sent to user wallet on the source chain\n    /// $ESORDER rewards are staked to the user\n    function _ledgerClaimRewards(\n        uint32 _distributionId,\n        address _user,\n        uint256 _srcChainId,\n        uint256 _cumulativeAmount,\n        bytes32[] memory _merkleProof\n    ) internal {\n        (LedgerToken token, uint256 claimedAmount) = _claimRewards(_distributionId, _user, _srcChainId, _cumulativeAmount, _merkleProof);\n\n        if (claimedAmount != 0) {\n            if (token == LedgerToken.ESORDER) {\n                _stake(_user, _srcChainId, token, claimedAmount);\n            } else if (token == LedgerToken.ORDER) {\n                OCCLedgerMessage memory message = OCCLedgerMessage({\n                    dstChainId: _srcChainId,\n                    token: LedgerToken.ORDER,\n                    tokenAmount: claimedAmount,\n                    receiver: _user,\n                    payloadType: uint8(PayloadDataType.ClaimRewardBackward),\n                    payload: \"0x0\"\n                });\n                ILedgerOCCManager(occAdaptor).ledgerSendToVault(message);\n            }\n        }\n    }\n\n    /// @notice Withdrawn $ORDER tokens are sent back to the user wallet on the source chain\n    function _ledgerWithdrawOrder(address _user, uint256 _chainId) internal {\n        uint256 orderAmountForWithdraw = _withdrawOrder(_user, _chainId);\n        if (orderAmountForWithdraw != 0) {\n            OCCLedgerMessage memory message = OCCLedgerMessage({\n                dstChainId: _chainId,\n                token: LedgerToken.ORDER,\n                tokenAmount: orderAmountForWithdraw,\n                receiver: _user,\n                payloadType: uint8(PayloadDataType.WithdrawOrderBackward),\n                payload: \"0x0\"\n            });\n            ILedgerOCCManager(occAdaptor).ledgerSendToVault(message);\n        }\n    }\n\n    /// @notice Claimed USDC revenue is sent back to the user wallet on the source chain\n    function _ledgerClaimUsdcRevenue(address _user, uint256 _chainId) internal {\n        uint256 usdcRevenueAmount = _claimUsdcRevenue(_user, _chainId);\n        if (usdcRevenueAmount != 0) {\n            OCCLedgerMessage memory message = OCCLedgerMessage({\n                dstChainId: _chainId,\n                token: LedgerToken.USDC,\n                tokenAmount: usdcRevenueAmount,\n                receiver: _user,\n                payloadType: uint8(PayloadDataType.ClaimUsdcRevenueBackward),\n                payload: \"0x0\"\n            });\n            ILedgerOCCManager(occAdaptor).ledgerSendToVault(message);\n        }\n    }\n\n    /// @notice Claimed ORDER tokens should be sent to the user wallet on the source chain\n    function _ledgerClaimVestingRequest(address _user, uint256 _chainId, uint256 _requestId) internal {\n        (uint256 claimedOrderAmount, uint256 unclaimedOrderAmount) = _claimVestingRequest(_user, _chainId, _requestId);\n\n        if (claimedOrderAmount != 0) {\n            OCCLedgerMessage memory message = OCCLedgerMessage({\n                dstChainId: _chainId,\n                token: LedgerToken.ORDER,\n                tokenAmount: claimedOrderAmount,\n                receiver: _user,\n                payloadType: uint8(PayloadDataType.ClaimVestingRequestBackward),\n                payload: \"0x0\"\n            });\n            ILedgerOCCManager(occAdaptor).ledgerSendToVault(message);\n        }\n\n        if (unclaimedOrderAmount != 0) {\n            ILedgerOCCManager(occAdaptor).collectUnvestedOrders(unclaimedOrderAmount);\n        }\n    }\n\n    /// @notice Before redeeming Valor need to collect pending Valor for the user\n    function _ledgerRedeemValor(address _user, uint256 _chainId, uint256 _amount) internal {\n        _updateValorVarsAndCollectUserValor(_user);\n        _redeemValor(_user, _chainId, _amount);\n    }\n\n    /// @notice When $ESORDER unstaked, it should be immediately vested\n    function _ledgerEsOrderUnstakeAndVest(address _user, uint256 _chainId, uint256 _amount) internal {\n        _esOrderUnstake(_user, _chainId, _amount);\n        _createVestingRequest(_user, _chainId, _amount);\n    }\n}\n"
    },
    "contracts/test/LedgerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {LedgerToken} from \"../lib/OCCTypes.sol\";\nimport {LedgerSignedTypes} from \"../lib/LedgerTypes.sol\";\nimport {Signature} from \"../lib/Signature.sol\";\nimport {OmnichainLedgerV1} from \"../OmnichainLedgerV1.sol\";\n\ncontract LedgerTest is OmnichainLedgerV1 {\n    function claimRewards(\n        uint32 _distributionId,\n        address _user,\n        uint256 _srcChainId,\n        uint256 _cumulativeAmount,\n        bytes32[] calldata _merkleProof\n    ) external {\n        (LedgerToken token, uint256 claimedAmount) = _claimRewards(_distributionId, _user, _srcChainId, _cumulativeAmount, _merkleProof);\n\n        if (claimedAmount != 0) {\n            if (token == LedgerToken.ORDER) {\n                // $ORDER rewards are sent to user wallet on the source chain\n            } else if (token == LedgerToken.ESORDER) {\n                _stake(_user, _srcChainId, token, claimedAmount);\n            } else {\n                revert UnsupportedToken();\n            }\n        }\n    }\n\n    function setTotalValorAmount(uint256 _amount) external {\n        totalValorAmount = _amount;\n    }\n\n    function setCollectedValor(address _user, uint256 _amount) external {\n        collectedValor[_user] = _amount;\n    }\n\n    function redeemValor(address _user, uint256 _chainId, uint256 _amount) external {\n        _ledgerRedeemValor(_user, _chainId, _amount);\n    }\n\n    function claimUsdcRevenue(address _user, uint256 _chainId) external {\n        _claimUsdcRevenue(_user, _chainId);\n    }\n\n    function stake(address _user, uint256 _chainId, LedgerToken _token, uint256 _amount) external {\n        _stake(_user, _chainId, _token, _amount);\n    }\n\n    function createOrderUnstakeRequest(address _user, uint256 _chainId, uint256 _amount) external {\n        _createOrderUnstakeRequest(_user, _chainId, _amount);\n    }\n\n    function cancelOrderUnstakeRequest(address _user, uint256 _chainId) external {\n        _cancelOrderUnstakeRequest(_user, _chainId);\n    }\n\n    function withdrawOrder(address _user, uint256 _chainId) external {\n        _withdrawOrder(_user, _chainId);\n    }\n\n    function esOrderUnstakeAndVest(address _user, uint256 _chainId, uint256 _amount) external {\n        _ledgerEsOrderUnstakeAndVest(_user, _chainId, _amount);\n    }\n\n    function createVestingRequest(address _user, uint256 _chainId, uint256 _amountEsorder) external {\n        _createVestingRequest(_user, _chainId, _amountEsorder);\n    }\n\n    function cancelVestingRequest(address _user, uint256 _chainId, uint256 _requestId) external returns (uint256 esOrderAmountToStakeBack) {\n        esOrderAmountToStakeBack = _cancelVestingRequest(_user, _chainId, _requestId);\n    }\n\n    function cancelAllVestingRequests(address _user, uint256 _chainId) external returns (uint256 esOrderAmountToStakeBack) {\n        esOrderAmountToStakeBack = _cancelAllVestingRequests(_user, _chainId);\n    }\n\n    function claimVestingRequest(\n        address _user,\n        uint256 _chainId,\n        uint256 _requestId\n    ) external returns (uint256 claimedOrderAmount, uint256 unclaimedOrderAmount) {\n        (claimedOrderAmount, unclaimedOrderAmount) = _claimVestingRequest(_user, _chainId, _requestId);\n    }\n\n    function nuberOfUsersBatchedRedemptionRequests(address _user) external view returns (uint256) {\n        return userRevenue[_user].requests.length;\n    }\n\n    function dailyUsdcNetFeeRevenueTestNoSignatureCheck(uint256 _usdcNetFeeRevenue) public onlyRole(TREASURE_UPDATER_ROLE) {\n        _dailyUsdcNetFeeRevenueTest(_usdcNetFeeRevenue, block.timestamp);\n    }\n\n    function dailyUsdcNetFeeRevenueTestNoTimeCheck(LedgerSignedTypes.UintValueData calldata data) external onlyRole(TREASURE_UPDATER_ROLE) {\n        Signature.verifyUintValueSignature(data, usdcUpdaterAddress);\n        _dailyUsdcNetFeeRevenueTest(data.value, data.timestamp);\n    }\n\n    function _dailyUsdcNetFeeRevenueTest(uint256 _usdcNetFeeRevenue, uint256 _timestamp) public onlyRole(TREASURE_UPDATER_ROLE) {\n        lastUsdcNetFeeRevenueUpdateTimestamp = block.timestamp;\n        totalUsdcInTreasure += _usdcNetFeeRevenue;\n        _updateValorToUsdcRateScaled();\n        emit DailyUsdcNetFeeRevenueUpdated(_timestamp, _usdcNetFeeRevenue, totalUsdcInTreasure, totalValorAmount, valorToUsdcRateScaled);\n        _possiblyFixBatchValorToUsdcRateForPreviousBatch();\n    }\n}\n"
    },
    "contracts/test/OmnichainLedgerTestV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport {IOFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {LedgerToken} from \"../lib/OCCTypes.sol\";\nimport {OmnichainLedgerV1} from \"../OmnichainLedgerV1.sol\";\n\ncontract OmnichainLedgerTestV1 is OmnichainLedgerV1 {\n    function setBatchDuration(uint256 _batchDuration) external {\n        batchDuration = _batchDuration;\n    }\n\n    function setUnstakeLockPeriod(uint256 _unstakeLockPeriod) external {\n        unstakeLockPeriod = _unstakeLockPeriod;\n    }\n\n    function setVestingLockPeriod(uint256 _vestingLockPeriod) external {\n        vestingLockPeriod = _vestingLockPeriod;\n    }\n\n    function setVestingLinearPeriod(uint256 _vestingLinearPeriod) external {\n        vestingLinearPeriod = _vestingLinearPeriod;\n    }\n\n    function setBatchStartTimestamp(uint256 _batchStartTimestamp) external {\n        batchStartTimestamp = _batchStartTimestamp;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}