// generate typescript wrapper for foundry


const argv = require('minimist')(process.argv.slice(2));

// input sol script path
if (argv.sol === undefined) {
    console.error(`Usage: ts-node foundry_ts/genCode.ts --sol <path_to_foundry_script>`);
    process.exit(1);
}

// input deploy flag
// whether a deploy script should be generated
if (argv.deploy === undefined) {
    argv.deploy = false;
}

// output dir
const outDir = "scripts/ts_foundry/methods"

const outFileName = argv.sol.split("/").pop().split(".")[0];
const outPath = `${outDir}/${outFileName}.ts`; 

console.log(`generating code for ${argv.sol} to ${outPath}`);

// read text contect from sol script
const fs = require('fs');
const solText = fs.readFileSync(argv.sol, 'utf8');
// all arguments are formatted as vm.env<type>(FS_<operation_name>_<argument_name>
const myArguments = solText.match(/vm.env[a-zA-Z0-9_]+\(\"FS_[a-zA-Z0-9_]+_[a-zA-Z0-9_]+\"\)/g);
console.log(`found ${myArguments.length} arguments`);
console.log(myArguments)

// require length of arguments >= 1
if (myArguments.length < 1) {
    console.error(`no arguments found in ${argv.sol}`);
    process.exit(1);
}

function getArgName(arg: string) : string {
    return arg.split("_")[2].replace("\")", "");
}

function getArgType(arg: string) : string {
    const solType = arg.split("(")[0].replace("vm.env", "").toLowerCase();
    // convert sol type to typescript type
    switch (solType) {
        case "bytes":
            return "string";
        case "string":
            return "string";
        case "address":
            return "string";
        case "uint256":
            return "number";
        case "uint":
            return "number";
        case "bool":
            return "boolean";
        default:
            console.error(`unknown type ${solType}`);
            process.exit(1);
    }
}

const required_args = myArguments.map((arg: string) => {
    return { name: getArgName(arg), type: getArgType(arg) };
});
for (const arg of required_args) {
    console.log(`name: ${arg.name}, type: ${arg.type}`);
}

const operation_name = myArguments[0].split("_")[1];
console.log(`operation name: ${operation_name}`);

let broadcastPresent = false;

let requiredArgString = required_args.map((arg: any) => {
    return `\"${arg.name}\"`;
}).join(", ");

// format function argument string, to generate code
let argumentString = required_args.map((arg: any) => {
    if (arg.name === "broadcast") {
        broadcastPresent = true;
    }
    return `${arg.name}: ${arg.type}`;
}).join(", ");

let callingArgs = required_args.map((arg: any) => {
    return `argv.${arg.name}`;
}).join(", ");
if (!broadcastPresent) {
    argumentString += ", broadcast: boolean";
    callingArgs += ", argv.broadcast";
}
argumentString += ", simulate: boolean";
callingArgs += ", argv.simulate";
console.log(`argument string: ${argumentString}`);

let linesOfSettingEnvs = required_args.map((arg: any) => {
    const value = (arg.type === "boolean" || arg.type === "number") ? `${arg.name}.toString()` : `${arg.name}`;
    return `set_env_var(method_name, "${arg.name}", ${value});`;
}).join("\n    ");

let deployDataFile = argv.role === "manager" ? "ccmanager_deploy_json" : "relay_deploy_json";

let setDeployJsonLine = argv.deploy ? `setupDeployJson(${deployDataFile}, env, network, \"${argv.role}\");` : "\n";

// generate code
let code = `
// generated by scripts/ts_foundry/methods/gen.ts
// Path: ${argv.sol}
import { addOperation } from "../utils/config";
import { set_env_var, foundry_wrapper } from "../foundry";
import { checkArgs } from "../utils/helper";
import { setupDeployJson } from "../utils/setupDeployJson";

// current file name
const method_name = "${operation_name}";

export function ${operation_name}WithArgv(argv: any) {
    const required_flags = [${requiredArgString}];
    checkArgs(method_name, argv, required_flags);
    ${operation_name}(${callingArgs});
}

export function ${operation_name}(${argumentString}) {
    ${setDeployJsonLine}
    ${linesOfSettingEnvs}
    foundry_wrapper(method_name, broadcast, simulate);

}

addOperation(method_name, ${operation_name}WithArgv);
`;

// write code to file
console.log(`writing code to ${outPath}`);
fs.writeFileSync(outPath, code);

// touch index.ts
// add import line into index.ts

const indexFile = "scripts/ts_foundry/methods/index.ts";

console.log(`adding import line to ${indexFile}`);
const indexContent = fs.readFileSync(indexFile, 'utf8');

const importLine = `\nimport "./${outFileName}";`;

// check if import line already exists
if (indexContent.indexOf(importLine) === -1) {
    fs.appendFileSync(indexFile, importLine);
}
console.log(`code generated to ${outPath}`);
console.log(`import line added to ${indexFile}`);
